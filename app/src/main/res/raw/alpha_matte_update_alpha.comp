#version 310 es

layout(local_size_x = 32, local_size_y = 32) in;
layout(std430) buffer;

uniform ivec2 dimensions;
uniform uint boundary_size;
uniform sampler2D trimap;

layout(binding = 0) writeonly buffer AlphaBuffer {
    int data[];
} alpha;

struct Sample
{
    int foreground_index, background_index;
    float distance2foreground, distance2background;
    float cost, alpha;
};

layout(binding = 4) writeonly buffer Samples {
    Sample data[];
} samples;


void main(){
    // rgba
    uvec4 TRIMAP_FOREGROUND = uvec4(0xff, 0xff, 0xff, 0xFF);
    uvec4 TRIMAP_BACKGROUND = uvec4(0x00, 0x00, 0x00, 0xFF);
    uvec4 TRIMAP_UNKNOWN    = uvec4(0x00, 0x00, 0x00, 0x00);

    int x = int(gl_GlobalInvocationID.x);
    int y = int(gl_GlobalInvocationID.y);

    if(x >= dimensions.x || y >= dimensions.y)
        return;

    vec2 tex_coord = vec2(
        float(x) / float(dimensions.x),
        float(y) / float(dimensions.y)
    );
    uvec4 trimap_pixel = uvec4(texture(trimap, tex_coord) * 255.0);

    /**/
    // assign right value
    int value = 0x00;
    if(trimap_pixel == TRIMAP_FOREGROUND)
        value = 0x00; // writing zero is not necessary
    else if(trimap_pixel == TRIMAP_BACKGROUND)
        value = 0xFF;
    else{
        Sample _sample = samples.data[y * dimensions.x + x];
        value = 0xFF - int(_sample.alpha * 255.0);
    }

    value = 0xFF - max(0, min(value, 0xFF));
    alpha.data[y*dimensions.x + x] =  (value << 24) | (value << 16) | (value << 8) | (value);
    /**/

    /*/
    // draw sample foreground and background
    int foreground_index = _sample.foreground_index;
    int background_index = _sample.background_index;

    ivec2 foreground_point = foregroundBoundary.data[foreground_index];
    ivec2 background_point = backgroundBoundary.data[background_index];

    alpha.data[foreground_point.y*dimensions.x + foreground_point.x] = 0xFFFFFFFF;
    alpha.data[background_point.y*dimensions.x + background_point.x] = 0x77777777;
    /**/

    /*/
    // draw boundary
    int idx = y*dimensions.x + x;
    if(idx < int(boundary_size)){
        ivec2 fpos = foregroundBoundary.data[idx];
        ivec2 bpos = backgroundBoundary.data[idx];

        alpha.data[fpos.y*dimensions.x + fpos.x] = 0xFFFFFFFF;
        alpha.data[bpos.y*dimensions.x + bpos.x] = 0xFFFFFFFF;
    }
    /**/
}