#version 310 es

layout(local_size_x = 32, local_size_y = 32) in;
layout(std430) buffer;

uniform ivec2 dimensions;
uniform int boundary_size;
uniform int iteration;

uniform sampler2D image;
uniform sampler2D trimap;

layout(binding = 0) writeonly buffer AlphaBuffer {
    int data[];
} alpha;

layout(binding = 1) readonly buffer BackgroundBoundary {
    ivec2 data[];
} backgroundBoundary;

layout(binding = 2) readonly buffer ForegroundBoundary {
    ivec2 data[];
} foregroundBoundary;

struct Sample
{
    int foreground_index, background_index;
    float distance2foreground, distance2background;
    float cost, alpha;
};

layout(binding = 3) writeonly buffer Samples {
    Sample data[];
} sampler;

float random(uint x,float minVal,float maxVal){
	x=x*(x*(x*(x*(x+1)+1)+1)+1);
	float t=float(x)/float(uint(-1));
	return minVal+t*(maxVal-minVal);
}

float nearestDistance(ivec2 data[], ivec2 point) {
    // INT_MAX    = +2147483647
    int minDistSqr = 2147483647;
    for (int i = 0; i < boundary_size; ++i)
    {
        ivec2 delta = boundary[i] - point;
        ivec2 dist_to_boundary = pow(delta.x, 2) + pow(delta.y, 2);
        minDistSqr = min(minDistSqr, dist_to_boundary);
    }

    return sqrt(minDistSqr);
}

void main(){
    // rgba
    uvec4 TRIMAP_UNKNOWN = uvec4(0x00, 0x00, 0x00, 0x00);

    int x = int(gl_GlobalInvocationID.x);
    int y = int(gl_GlobalInvocationID.y);

    if(x >= dimensions.x || y >= dimensions.y)
        return;

    vec2 tex_coord = vec2(float(x) / float(dimensions.x), float(y) / float(dimensions.y));
    vec4 trimap_pixel = uvec4(texture(trimap, tex_coord) * 255.0);

    if(trimap_pixel != TRIMAP_UNKNOWN)
        return;

    // FLT_MAX      = 3.402823e+38
    Sample _sample = Sample(
        int(random(gl_LocalInvocationIndex, 0, boundary_size-1)),
        int(random(gl_LocalInvocationIndex, 0, boundary_size-1)),
        0.0, 0.0,
        3.402823e+38, 0);

    _sample.distance2background = nearestDistance(backgroundBoundary, x, y);
    _sample.distance2foreground = nearestDistance(foregroundBoundary, x, y);

    samples.data[y*dimensions.x + x] = _sample;
}