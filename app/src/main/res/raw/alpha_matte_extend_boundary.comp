#version 310 es

layout(local_size_x = 32, local_size_y = 32) in;
layout(std430) buffer;

uniform ivec2 dimensions;
uniform uint boundary_size;
uniform sampler2D trimap;

//layout(binding = 0) writeonly buffer AlphaBuffer {
//    int data[];
//} alpha;

layout(binding = 1) writeonly buffer BackgroundBoundary {
    ivec2 data[];
} backgroundBoundary;

layout(binding = 2) writeonly buffer ForegroundBoundary {
    ivec2 data[];
} foregroundBoundary;

layout(binding = 3, offset = 0) uniform atomic_uint atomic_counter_background;
layout(binding = 3, offset = 4) uniform atomic_uint atomic_counter_foreground;

float rand(vec2 co) {
    float a = 12.9898;
    float b = 78.233;
    float c = 43758.5453;
    float dt= dot(co.xy ,vec2(a,b));
    float sn= mod(dt,3.14);
    return fract(sin(sn) * c);
}

void main(){
    // rgba
    uvec4 TRIMAP_FOREGROUND = uvec4(0xff, 0xff, 0xff, 0xFF);
    uvec4 TRIMAP_BACKGROUND = uvec4(0x00, 0x00, 0x00, 0xFF);
    uvec4 TRIMAP_UNKNOWN    = uvec4(0x00, 0x00, 0x00, 0x00);

    // random access
    vec2 tex_coord = vec2(
        rand(vec2(gl_GlobalInvocationID)),
        rand(vec2(gl_GlobalInvocationID) * 39.0)
    );

    uvec4 trimap_pixel = uvec4(texture(trimap, tex_coord) * 255.0);

    ivec2 coord = ivec2(tex_coord.x * float(dimensions.x), tex_coord.y * float(dimensions.y));
    if(trimap_pixel == TRIMAP_FOREGROUND){
        uint prev_values = atomicCounterIncrement(atomic_counter_foreground);
        if(prev_values < boundary_size){
            foregroundBoundary.data[prev_values] = coord;
//            alpha.data[coord.y*dimensions.x + coord.x] = 0xFFFFFFFF;
        }
    }
    else if(trimap_pixel == TRIMAP_BACKGROUND) {
        uint prev_values = atomicCounterIncrement(atomic_counter_background);
        if(prev_values < boundary_size){
            backgroundBoundary.data[prev_values] = coord;
//            alpha.data[coord.y*dimensions.x + coord.x] = 0xFFFFFFFF;
        }
    }
}