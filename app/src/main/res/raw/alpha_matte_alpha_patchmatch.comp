#version 310 es

layout(local_size_x = 32, local_size_y = 32) in;
layout(std430) buffer;

uniform ivec2 dimensions;
uniform int boundary_size;

uniform sampler2D image;
uniform sampler2D trimap;

layout(binding = 0) writeonly buffer AlphaBuffer {
    int data[];
} alpha;

layout(binding = 1) readonly buffer BackgroundBoundary {
    ivec2 data[];
} backgroundBoundary;

layout(binding = 2) readonly buffer ForegroundBoundary {
    ivec2 data[];
} foregroundBoundary;

struct Sample
{
    int foreground_index, background_index;
    float distance2foreground, distance2background;
    float cost, alpha;
};

layout(binding = 3) writeonly buffer Samples {
    Sample data[];
} sampler;

float nearestDistance(ivec2 data[], ivec2 point) {
    // INT_MAX    = +2147483647
    int minDistSqr = 2147483647;
    for (int i = 0; i < boundary_size; ++i)
    {
        ivec2 delta = boundary[i] - point;
        ivec2 dist_to_boundary = pow(delta.x, 2) + pow(delta.y, 2);
        minDistSqr = min(minDistSqr, dist_to_boundary);
    }

    return sqrt(minDistSqr);
}

float random(uint x, float minVal, float maxVal){
	x=x*(x*(x*(x*(x+1)+1)+1)+1);
	float t=float(x)/float(uint(-1));
	return minVal+t*(maxVal-minVal);
}

// Eq. 4
float distCost(ivec2 p0, ivec2 p1, float minDist) {
    ivec2 delta = p0 - p1;
    float dist = pow(delta.x, 2.0) + pow(delta.y, 2.0);
    return sqrt(dist) / (minDist + 1e-6f);
}

float colorDist(uvec4 a, uvec4 b) {
    return sqrt(pow(a.r - b.r, 2) + pow(a.g - b.g, 2) + pow(a.b - b.b, 2));
}

void main(){
    // rgba
    uvec4 TRIMAP_FOREGROUND = uvec4(0xff, 0xff, 0xff, 0xFF);
    uvec4 TRIMAP_BACKGROUND = uvec4(0x00, 0x00, 0x00, 0xFF);
    uvec4 TRIMAP_UNKNOWN    = uvec4(0x00, 0x00, 0x00, 0x00);

    int x = int(gl_GlobalInvocationID.x);
    int y = int(gl_GlobalInvocationID.y);

    if(x >= dimensions.x || y >= dimensions.y)
        return;

    vec2 tex_coord = vec2(
        float(x) / float(dimensions.x),
        float(y) / float(dimensions.y)
    );
    uvec4 trimap_pixel = uvec4(texture(trimap, tex_coord) * 255.0);

    if(trimap_pixel != TRIMAP_UNKNOWN) {
        ivec2 current_point = ivec2(x, y);

        Sample _sample = samples.data[y * dimensions.x + x];

        uvec4 image_color = uvec4(texture(trimap, tex_coord) * 255.0);
        for(int iteration = 0; iteration < 10; iteration++){
            // propagation
            for (int y2 = y - 1; y2 <= y + 1; ++y2) {
                for (int x2 = x - 1; x2 <= x + 1; ++x2) {
                    if (x2 < 0 || x2 >= dimensions.x || y2 < 0 || y2 >= dimensions.y)
                        continue;

                    vec2 current_tex_coord = vec2(
                        float(x2) / float(dimensions.x),
                        float(y2) / float(dimensions.y)
                    );
                    uvec4 current_trimap_pixel = uvec4(texture(trimap, tex_coord) * 255.0);
                    if(current_trimap_pixel != TRIMAP_UNKNOWN)
                        return;

                    Sample second_sample = samples.data[y2*dimensions.x + x2];
                    int foreground_index = second_sample.foreground_index;
                    int background_index = second_sample.background_index;

                    ivec2 foreground_point = foregroundBoundary.data[foreground_index];
                    ivec2 background_point = backgroundBoundary.data[background_index];

                    vec2 tex_coord_foreground = vec2(
                        float(foreground_point.x) / float(dimensions.x),
                        float(foreground_point.y) / float(dimensions.y)
                    );
                    vec2 tex_coord_backgroun = vec2(
                        float(background_point.x) / float(dimensions.x),
                        float(background_point.y) / float(dimensions.y)
                    );
                    uvec4 foreground_color = uvec4(texture(image, tex_coord_foreground) * 255.0);
                    uvec4 background_color = uvec4(texture(image, tex_coord_backgroun) * 255.0);

                    float alpha = calculateAlpha(foreground_color, background_color, image_color);

                    float cost = colorCost(foreground_color, background_color, image_color, alpha) +
                        distCost(current_point, foreground_point, _sample.distance2foreground) +
                        distCost(current_point, background_point, _sample.distance2background);

                    if (cost < _sample.cost) {
                        _sample.foreground_index = foreground_index;
                        _sample.background_index = background_index;
                        _sample.cost = cost;
                        _sample.alpha = alpha;
                    }
                }
            }

            int max_boundary_width = boundary_size;
            float r;
            // random walk
            for (int k = 0; (r = max_boundary_width * pow(0.5f, k)) > 1f; k++) {
                int foreground_distance = int(r * (random(gl_LocalInvocationIndex, 0f, 1f)));
                int background_distance = int(r * (random(gl_LocalInvocationIndex, 0f, 1f)));

                int foreground_index = _sample.foreground_index + foreground_distance;
                int background_index = _sample.background_index + background_distance;

                foreground_index = foreground_index >= max_boundary_width ?
                                   foreground_index - max_boundary_width : foreground_index;
                background_index = background_index >= max_boundary_width ?
                                   background_index - max_boundary_width : background_index;

                ivec2 foreground_point = foregroundBoundary.data[foreground_index];
                ivec2 background_point = backgroundBoundary.data[background_index];

                vec2 tex_coord_foreground = vec2(
                    float(foreground_point.x) / float(dimensions.x),
                    float(foreground_point.y) / float(dimensions.y)
                );
                vec2 tex_coord_background = vec2(
                    float(background_point.x) / float(dimensions.x),
                    float(background_point.y) / float(dimensions.y)
                );
                uvec4 foreground_color = uvec4(texture(image, tex_coord_foreground) * 255.0);
                uvec4 background_color = uvec4(texture(image, tex_coord_background) * 255.0);

                float alpha = calculateAlpha(foreground_color, background_color, image_color);

                float cost = colorCost(foreground_color, background_color, image_color, alpha) +
                    distCost(current_point, foreground_point, _sample.distance2foreground) +
                    distCost(current_point, background_point, _sample.distance2background);

                if (cost < _sample.cost) {
                    _sample.foreground_index = foreground_index;
                    _sample.background_index = background_index;
                    _sample.cost = cost;
                    _sample.alpha = alpha;
                }
            }
        }
    }

    // assign right value
    int value = 0x00;
    if(trimap_pixel == TRIMAP_FOREGROUND)
        value = 0x00;
    else if(trimap_pixel == TRIMAP_BACKGROUND)
        value = 0xFF;
    else
        value = int(_sample.alpha * 255.0);

    value = max(0, min(value, 255));
    alpha.data[y*dimensions.x + x] =  (value << 24) | (value << 16) | (value << 8) | (value);
}