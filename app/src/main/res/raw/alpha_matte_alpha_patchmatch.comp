#version 310 es

layout(local_size_x = 32, local_size_y = 32) in;
layout(std430) buffer;

uniform ivec2 dimensions;
uniform uint boundary_size;
uniform sampler2D image;
uniform sampler2D trimap;

layout(binding = 0) writeonly buffer AlphaBuffer {
    int data[];
} alpha;

layout(binding = 1) readonly buffer BackgroundBoundary {
    ivec2 data[];
} backgroundBoundary;

layout(binding = 2) readonly buffer ForegroundBoundary {
    ivec2 data[];
} foregroundBoundary;

struct Sample
{
    int foreground_index, background_index;
    float distance2foreground, distance2background;
    float cost, alpha;
};

layout(binding = 4) writeonly buffer Samples {
    Sample data[];
} samples;

float rand(vec2 co) {
    float a = 12.9898;
    float b = 78.233;
    float c = 43758.5453;
    float dt= dot(co.xy ,vec2(a,b));
    float sn= mod(dt,3.14);
    return fract(sin(sn) * c);
}

float distCost(ivec2 p0, ivec2 p1, float minDist) {
    vec2 delta = vec2(p0 - p1);
    float dist = pow(delta.x, 2.0) + pow(delta.y, 2.0);
    return sqrt(dist) / (minDist + 1e-6f);
}

float colorDist(uvec4 a, uvec4 b) {
    return sqrt(pow(float(a.r - b.r), 2.0) + pow(float(a.g - b.g), 2.0) + pow(float(a.b - b.b), 2.0));
}

// Eq. 2
float calculateAlpha(uvec4 foreground, uvec4 background, uvec4 image)
{
    float result = float(
                    (image.r - background.r) * (foreground.r - background.r) +
                    (image.g - background.g) * (foreground.g - background.g) +
                    (image.b - background.b) * (foreground.b - background.b));
    float div = 1e-6f + float(
                (foreground.r - background.r) * (foreground.r - background.r) +
                (foreground.g - background.g) * (foreground.g - background.g) +
                (foreground.b - background.b) * (foreground.b - background.b));

    return min(max(result / div, 0.0), 1.0);
}

// Eq. 3
float colorCost(uvec4 foreground, uvec4 background, uvec4 image, float alpha)
{
    vec4 _foreground = vec4(foreground);
    vec4 _background = vec4(background);
    vec4 _image = vec4(image);
    float result = pow(_image.r - (alpha * _foreground.r + (1.0 - alpha) * _background.r), 2.0) +
                   pow(_image.g - (alpha * _foreground.g + (1.0 - alpha) * _background.g), 2.0) +
                   pow(_image.b - (alpha * _foreground.b + (1.0 - alpha) * _background.b), 2.0);
    return sqrt(result);
}

void main(){
    // rgba
    uvec4 TRIMAP_FOREGROUND = uvec4(0xff, 0xff, 0xff, 0xFF);
    uvec4 TRIMAP_BACKGROUND = uvec4(0x00, 0x00, 0x00, 0xFF);
    uvec4 TRIMAP_UNKNOWN    = uvec4(0x00, 0x00, 0x00, 0x00);

    int x = int(gl_GlobalInvocationID.x);
    int y = int(gl_GlobalInvocationID.y);

    if(x >= dimensions.x || y >= dimensions.y)
        return;

    vec2 tex_coord = vec2(
        float(x) / float(dimensions.x),
        float(y) / float(dimensions.y)
    );
    uvec4 trimap_pixel = uvec4(texture(trimap, tex_coord) * 255.0);
    Sample _sample = samples.data[y * dimensions.x + x];

    if(trimap_pixel == TRIMAP_UNKNOWN) {
        ivec2 current_point = ivec2(x, y);

        uvec4 image_color = uvec4(texture(image, tex_coord) * 255.0);
        // propagation
        for (int y2 = y - 1; y2 <= y + 1; ++y2) {
            for (int x2 = x - 1; x2 <= x + 1; ++x2) {
                if (x2 < 0 || x2 >= dimensions.x || y2 < 0 || y2 >= dimensions.y)
                    continue;

                vec2 current_tex_coord = vec2(
                    float(x2) / float(dimensions.x),
                    float(y2) / float(dimensions.y)
                );
                uvec4 current_trimap_pixel = uvec4(texture(trimap, current_tex_coord) * 255.0);
                if(current_trimap_pixel != TRIMAP_UNKNOWN)
                    continue;

                Sample second_sample = samples.data[y2*dimensions.x + x2];
                int foreground_index = second_sample.foreground_index;
                int background_index = second_sample.background_index;

                ivec2 foreground_point = foregroundBoundary.data[foreground_index];
                ivec2 background_point = backgroundBoundary.data[background_index];

                vec2 tex_coord_foreground = vec2(
                    float(foreground_point.x) / float(dimensions.x),
                    float(foreground_point.y) / float(dimensions.y)
                );
                vec2 tex_coord_background = vec2(
                    float(background_point.x) / float(dimensions.x),
                    float(background_point.y) / float(dimensions.y)
                );
                uvec4 foreground_color = uvec4(texture(image, tex_coord_foreground) * 255.0);
                uvec4 background_color = uvec4(texture(image, tex_coord_background) * 255.0);

                float alpha = calculateAlpha(foreground_color, background_color, image_color);

                float cost = colorCost(foreground_color, background_color, image_color, alpha) +
                    distCost(current_point, foreground_point, _sample.distance2foreground) +
                    distCost(current_point, background_point, _sample.distance2background);

                if (cost < _sample.cost) {
                    _sample.foreground_index = foreground_index;
                    _sample.background_index = background_index;
                    _sample.cost = cost;
                    _sample.alpha = alpha;
                }
            }
        }

        int max_boundary_width = int(boundary_size);
        float r;
        // random walk
        for (int k = 0; (r = float(max_boundary_width) * pow(0.5, float(k))) > 1.0; k++) {
            int distance = int(2.0*r * (rand(vec2(gl_GlobalInvocationID) * 29.0)) - r);

            int foreground_index = _sample.foreground_index + distance;
            int background_index = _sample.background_index + distance;

            if(foreground_index < 0)
                foreground_index = max_boundary_width + foreground_index;
            if(foreground_index >= max_boundary_width)
                foreground_index = foreground_index - max_boundary_width;

            if(background_index < 0)
                background_index = max_boundary_width + background_index;
            if(background_index >= max_boundary_width)
                background_index = background_index - max_boundary_width;

            ivec2 foreground_point = foregroundBoundary.data[foreground_index];
            ivec2 background_point = backgroundBoundary.data[background_index];

            vec2 tex_coord_foreground = vec2(
                float(foreground_point.x) / float(dimensions.x),
                float(foreground_point.y) / float(dimensions.y)
            );
            vec2 tex_coord_background = vec2(
                float(background_point.x) / float(dimensions.x),
                float(background_point.y) / float(dimensions.y)
            );
            uvec4 foreground_color = uvec4(texture(image, tex_coord_foreground) * 255.0);
            uvec4 background_color = uvec4(texture(image, tex_coord_background) * 255.0);

            float alpha = calculateAlpha(foreground_color, background_color, image_color);

            float cost = colorCost(foreground_color, background_color, image_color, alpha) +
                distCost(current_point, foreground_point, _sample.distance2foreground) +
                distCost(current_point, background_point, _sample.distance2background);

            if (cost < _sample.cost) {
                _sample.foreground_index = foreground_index;
                _sample.background_index = background_index;
                _sample.cost = cost;
                _sample.alpha = alpha;
            }
        }
    }

//     barrier(); // ???
    samples.data[y * dimensions.x + x] = _sample;
}